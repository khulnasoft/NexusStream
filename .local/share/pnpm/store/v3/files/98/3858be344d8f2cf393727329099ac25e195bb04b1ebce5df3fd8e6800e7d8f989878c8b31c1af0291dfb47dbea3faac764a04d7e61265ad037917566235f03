var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { dirname, join, resolve } from 'node:path';
import { asArray, globby, readJson, resolveTsConfig } from './util.mjs';
export const getTsconfigTargets = (tsconfig, cwd) => asArray(tsconfig).reduce((targets, file) => {
    var _a, _b, _c, _d;
    const tsconfigJson = resolveTsConfig(resolve(cwd, file));
    const outDir = (_a = tsconfigJson === null || tsconfigJson === void 0 ? void 0 : tsconfigJson.compilerOptions) === null || _a === void 0 ? void 0 : _a.outDir;
    const module = (_d = (_b = tsconfigJson === null || tsconfigJson === void 0 ? void 0 : tsconfigJson.compilerOptions) === null || _b === void 0 ? void 0 : (_c = _b.module).toLowerCase) === null || _d === void 0 ? void 0 : _d.call(_c);
    if (outDir && module.startsWith('es')) {
        targets.push(outDir);
    }
    else {
        console.warn('tsconfig should declare `outDir` and `module` type es6 or above');
    }
    return targets;
}, []);
export const getLocalModules = (sources, targets, cwd) => globby(getPatterns(sources, targets), {
    cwd,
    onlyFiles: true,
    absolute: true,
});
export const getExternalModules = (cwd) => __awaiter(void 0, void 0, void 0, function* () {
    const { names, files: esmModules } = yield getExternalEsmModules(cwd);
    const cjsModules = yield globby([
        '!node_modules/.cache',
        '!node_modules/.bin',
        '!node_modules/**/node_modules',
        ...names.map(m => `!node_modules/${m}`),
        'node_modules/**/*.(m|c)?js',
    ], {
        cwd,
        onlyFiles: true,
        absolute: true,
    });
    return {
        cjsModules,
        esmModules,
        allPackages: names,
    };
});
const getPatterns = (sources, targets) => sources.length > 0
    ? sources.map((src) => src.includes('*') ? src : `${src}/**/*.{ts,tsx}`)
    : targets.map((target) => target.includes('*') ? target : `${target}/**/*.{js,d.ts}`);
const getExportsEntries = (exports) => {
    const entries = Object.entries(exports);
    const parseConditional = (e) => typeof e === 'string' ? [e] : Object.values(e).map(parseConditional).flat(2);
    // has subpaths
    if (typeof exports !== 'string' && Object.keys(exports).some((k) => k.startsWith('.'))) {
        return entries.map(([k, v]) => [k, parseConditional(v)]);
    }
    return [['.', parseConditional(exports)]];
};
const getExternalEsmModules = (cwd) => globby(['node_modules/*/package.json', 'node_modules/@*/*/package.json'], {
    cwd,
    onlyFiles: true,
    absolute: true,
}).then((files) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield Promise.all(files
        .map((f) => __awaiter(void 0, void 0, void 0, function* () {
        const { name, exports } = yield readJson(f);
        if (!exports) {
            return { name };
        }
        const _dir = dirname(f);
        const exportsEntries = getExportsEntries(exports);
        return {
            name,
            files: (yield Promise.all(exportsEntries.map(([key, values]) => Promise.all(values.map((value) => __awaiter(void 0, void 0, void 0, function* () {
                return (yield globby(value, { cwd: _dir, onlyFiles: true, absolute: false }))
                    .map(file => join(file)
                    .replace(resolvePrefix('.', value), resolvePrefix(name, key)));
            })))))).flat(2)
        };
    })))).reduce((m, { name, files: _files }) => {
        if (name) {
            m.names.push(name);
        }
        if (_files) {
            m.files.push(..._files);
        }
        return m;
    }, { names: [], files: [] });
}));
const resolvePrefix = (prefix, pattern) => {
    if (!pattern) {
        return prefix;
    }
    let _pattern = pattern;
    if (_pattern.includes('*')) {
        _pattern = _pattern.slice(0, _pattern.indexOf('*'));
        if (_pattern.includes('/')) {
            _pattern = _pattern.slice(0, _pattern.lastIndexOf('/'));
        }
    }
    return join(prefix, _pattern);
};
