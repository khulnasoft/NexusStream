var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import path from 'node:path';
import { fixContents } from './fixes/index.mjs';
import { asArray, existsSync, read, readJson, remove, unixify, write, } from './util.mjs';
import { getLocalModules, getExternalModules, getTsconfigTargets, } from './finder.mjs';
import { normalizeOptions } from './options.mjs';
export const fixFilenameExtensions = (names, ext) => names.map((name) => name.endsWith('.d.ts')
    ? name
    : name.replace(/\.[^./\\]+$/, ext));
export const fix = (opts) => __awaiter(void 0, void 0, void 0, function* () {
    const options = normalizeOptions(opts);
    const ctx = yield resolve(options);
    yield patch(ctx, options);
});
const resolve = (opts) => __awaiter(void 0, void 0, void 0, function* () {
    const { cwd, target, src, tsconfig, out = cwd, ext, debug, unlink, sourceMap } = opts;
    const outDir = path.resolve(cwd, out);
    const sources = asArray(src);
    const targets = [...asArray(target), ...getTsconfigTargets(tsconfig, cwd)];
    debug('debug:cwd', cwd);
    debug('debug:outdir', outDir);
    debug('debug:sources', sources);
    debug('debug:targets', targets);
    const isSource = sources.length > 0;
    const localModules = yield getLocalModules(sources, targets, cwd);
    const { cjsModules, esmModules, allPackages } = yield getExternalModules(cwd);
    debug('debug:external-cjs-modules', cjsModules);
    debug('debug:external-esm-modules', esmModules);
    const ignore = [...esmModules, ...allPackages];
    const _localModules = typeof ext === 'string' ? fixFilenameExtensions(localModules, ext) : localModules;
    const allModules = [...cjsModules, ..._localModules];
    const allJsModules = [...cjsModules, ...fixFilenameExtensions(localModules, '.js')];
    debug('debug:local-modules', _localModules);
    return {
        outDir,
        isSource,
        ignore,
        allJsModules,
        allModules,
        _localModules,
        localModules
    };
});
const patch = (ctx, options) => __awaiter(void 0, void 0, void 0, function* () {
    const { cwd, unlink, sourceMap } = options;
    const { outDir, isSource, ignore, allJsModules, allModules, _localModules, localModules } = ctx;
    yield Promise.all(_localModules.map((name, i) => __awaiter(void 0, void 0, void 0, function* () {
        // NOTE d.ts may refer to .js ext only
        const all = name.endsWith('.d.ts') ? allJsModules : allModules;
        const originName = localModules[i];
        const nextName = (isSource ? originName : name)
            .replace(unixify(cwd), unixify(outDir));
        const contents = read(originName);
        const ctx = {
            options,
            contents,
            isSource,
            ignore,
            filename: name,
            filenames: all,
            originName,
            nextName,
        };
        const { contents: _contents } = fixContents(ctx);
        write(nextName, _contents);
        if (!isSource && unlink && cwd === outDir && nextName !== originName) {
            remove(originName);
        }
        if (sourceMap) {
            patchSourceFile(originName, nextName, unlink && cwd === outDir);
        }
    })));
});
const patchSourceFile = (name, nextName, unlink = false) => {
    if (name === nextName) {
        return;
    }
    const mapfile = `${name}.map`;
    if (!existsSync(mapfile)) {
        return;
    }
    const nextMapfile = `${nextName}.map`;
    const contents = readJson(mapfile);
    contents.file = path.basename(nextName);
    write(nextMapfile, JSON.stringify(contents));
    if (unlink) {
        remove(mapfile);
    }
};
